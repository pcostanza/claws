(in-package :claws)

(defconstant +qsort-grain-size+ #x500)

(defgeneric psort (sequence predicate &key key)
  (:documentation "Parallel quicksort implementation. Good for small core counts and small collection sizes."))

(defmethod psort ((list list) predicate &rest args &key key)
  (declare (list list) (ignore key) (dynamic-extent args) #.*optimization*)
  (if (list-length-less list +qsort-grain-size+)
    (apply #'sort list predicate args)
    (coerce (apply #'psort (coerce list 'simple-vector) predicate args) 'list)))

(defmethod psort :around ((vector vector) predicate &rest args &key key)
  (declare (vector vector) (dynamic-extent args) #.*optimization*)
  (if (< (length vector) +qsort-grain-size+)
    (apply #'sort vector predicate args)
    (apply #'call-next-method vector (get-function predicate) :key (if key (get-function key) #'identity) args)))

(defmacro define-psort-vector (type ref)
  `(defmethod psort ((vector ,type) predicate &key key)
     (declare (,type vector) (function predicate key) #.*optimization*)
     (labels ((median-of-three (l m r)
                (declare (fixnum l m r))
                (let ((lv (funcall key (,ref vector l)))
                      (mv (funcall key (,ref vector m)))
                      (rv (funcall key (,ref vector r))))
                  (cond ((funcall predicate lv mv)
                         (cond ((funcall predicate mv rv) m)
                               ((funcall predicate lv rv) r)
                               (t l)))
                        ((funcall predicate rv mv) m)
                        ((funcall predicate rv lv) r)
                        (t l))))

              (pseudo-median-of-nine (index size &aux (offset (ash size -3)))
                (declare (fixnum index size offset))
                (median-of-three
                 (median-of-three index (+ index offset) (+ index (* 2 offset)))
                 (median-of-three (+ index (* 3 offset)) (+ index (* 4 offset)) (+ index (* 5 offset)))
                 (median-of-three (+ index (* 6 offset)) (+ index (* 7 offset)) (1- (+ index size)))))

              (recur (index size)
                (declare (fixnum index size))
                (cond ((< size +qsort-grain-size+)
                       (sort (make-array size :displaced-to vector :displaced-index-offset index) predicate :key key))
                      (t (let* ((m (pseudo-median-of-nine index size))
                                (mv (funcall key (,ref vector m)))
                                (i index) (j (+ index size)))
                           (declare (fixnum m i j))
                           (rotatef (,ref vector index) (,ref vector m))
                           (loop named outer do
                                 (loop (decf j)
                                       (unless (funcall predicate mv (funcall key (,ref vector j)))
                                         (return)))
                                 (loop (when (= i j) (return-from outer))
                                       (incf i)
                                       (unless (funcall predicate (funcall key (,ref vector i)) mv)
                                         (return)))
                                 (when (= i j) (return-from outer))
                                 (rotatef (,ref vector i) (,ref vector j)))
                           (rotatef (,ref vector j) (,ref vector index))
                           (setq i (1+ j))
                           (spawn () (recur index (- j index)))
                           (recur i (- (+ index size) i))
                           (sync))))))
       (recur 0 (length vector)))
     vector))

(define-psort-vector vector aref)
(define-psort-vector simple-vector svref)
(define-psort-vector string char)
(define-psort-vector simple-string schar)
(define-psort-vector simple-base-string #+lispworks lw:sbchar #-lispworks schar)
(define-psort-vector bit-vector bit)
(define-psort-vector simple-bit-vector sbit)
